#!/usr/bin/python

# Copyright (C) 2013 Nguyen Hung Quy a.k.a dreamer2908
#
# Python CRC-32 Hasher v1.0 is free software; you can redistribute it 
# and/or modify it under the terms of the GNU General Public License 
# as published by the Free Software Foundation; either version 2 of 
# the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

import sys, os, zlib, glob, shutil, re

programName = "Python CRC-32 Hasher"
version = "1.0"
author = "dreamer2908"

addcrc = False
force = False
createsfv = False
sfvPath = "checksums.sfv"
sfvContent = "; Generated by %s v%s" % (programName, version)

# Open the file in binary mode (important) for reading
# Get a unit of data, call zlib.crc32 to get its hash. 
# Then get another unit, and call crc32 again; this time, 
# also give it the hash just got from previous data
# It will continue to calculate the hash. Repeat this until EOF.
# The hash got from calculating unit by unit is the same as 
# the one got from processing everything in one blast.
# Memory consuming is lower this way.
def crc32(fileName):
	fd = open(fileName,"rb")
	prev = None
	for eachLine in fd:
		if not prev:
			prev = zlib.crc32(eachLine)
		else:
			prev = zlib.crc32(eachLine, prev)
	fd.close()
	return prev

# From version 2.6, the return value is in the range [-2**31, 2**31-1], 
# and from ver 3.0, the return value is unsigned and in the range [0, 2**32-1]
# This works on both versions, confirmed by checking over 33 different files
def crc32_s(fileName):
	iHash = crc32(fileName)
	if sys.version_info[0] < 3 and iHash < 0: 
		iHash += 2 ** 32
	sHash = '%08X' % iHash
	return sHash

# In-used CRC-32 pattern: 8 characters of hexadecimal, 
# separated from the rest by some certain "special" characters.
# It's usually at the end of file name, so just take the last one; 
# there shouldn't more than one anyway.
def detectCRC(fileName):
	crc = ""
	found = False
	reCRC = re.compile(r'[A-Fa-f0-9]{8}')
	separator1 = "([_. "
	separator2 = ")]_. "
	for match in reCRC.finditer(fileName):
		start = match.start()
		end = match.end()
		if ((start == 0 or fileName[start - 1] in separator1) 
			and (end == len(fileName) or fileName[end + 1] in separator2)):
			crc = fileName[start:end]
			found = True

# Err... Process one file here
def processFile(fileName):
	sHash = crc32_s(fileName)
	newName = fileName

	found, crc = detectCRC(fileName)

	if sHash in fileName.upper():
		result = "File OK!"
	elif found:
		result = "File not OK! %s found in filename." % crc
	else:
		if addcrc:
			namae, ext = os.path.splitext(fileName)
			newName = namae + "[%s]" % sHash + ext
			try:
				shutil.move(fileName, newName)
				result = "CRC added!"
			except:
				result = "Renaming failed!"
				newName = fileName
		else:
			result = "CRC not found!"

	print("%s" % fileName)
	print("CRC: %s. Result: %s" % (sHash, result))

	# Append this to sfv's content. Yes, use newName as it's up-to-date
	# Use "global" to access external variable (important)
	path, name = os.path.split(newName)
	global sfvContent
	sfvContent += "\n%s %s" % (name, sHash)
	return found, crc

# Get all files matching mask in folder, and call processFile to process each one
def processFolder(folder, mask):
	files = glob.glob(os.path.join(folder, mask))
	for fileName in files:
		processFile(fileName)

# This is for something like "/var/www/upload/*OP*", or "~/Downloads/*.mkv"
# Just split folder and mask from path, and feed them to processFile
# Additionally do some verification to protect ourselves from user's trolling
def processFolderWithMask(path):
	folder, mask = os.path.split(path)
	passed = True
	if not os.path.isdir(folder):
		print('Error: Folder \"%s\" not found!' % folder)
		passed = False
	if passed:
		processFolder(folder, mask)

# Parse paramenters
pathList = []
i = 1
while i < len(sys.argv):
	arg = sys.argv[i]
	if arg == "-addcrc":
		addcrc = True
	elif arg == "-createsfv" and i < len(sys.argv) - 1:
		createsfv = True
		sfvPath = sys.argv[i+1]
		i += 1
	elif arg == "-f":
		force == True
	else:
		pathList.append(arg)
	i += 1

# Print user manual
if len(pathList) < 1:
	print("%s v%s by %s\n" % (programName, version, author))
	print("Syntax: python crc32.py [options] inputs\n")
	print("Input can be individual files, and/or folders.")
	print("  Use the asterisk wildcard for the file name pattern.\n")
	print("Options:")
	print("  -addcrc                        Add CRC to filenames")
	print("  -createsfv out.sfv             Create a SFV file\n")
	print("Examples:")
	print('  python crc32.py \"/home/yumi/Desktop/[FFF] Unbreakable Machine-Doll - 11 [A3A1001B].mkv\"')
	print('  python crc32.py ~/Downloads')
	print('  python crc32.py ~/Downloads/*.mkv')
	print('  python crc32.py -createsfv checksums.sfv ~/Downloads /var/www/upload/*OP*',
		' \"[FFF] Unbreakable Machine-Doll - 11 [A3A1001B].mkv\"')
	sys.exit()

# Process files and folders
for path in pathList:
	if os.path.isdir(path):
		processFolder(path, "*")
	elif os.path.isfile(path):
		processFile(path)
	elif "*" in path:
		processFolderWithMask(path)

# Write output SFV file
if createsfv:
	f = open(sfvPath, "w")
	f.write(sfvContent)
	f.close()