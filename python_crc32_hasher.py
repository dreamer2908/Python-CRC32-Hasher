#!/usr/bin/python

# Copyright (C) 2013 Nguyen Hung Quy a.k.a dreamer2908
#
# Python CRC-32 Hasher v1.0 is free software; you can redistribute it 
# and/or modify it under the terms of the GNU General Public License 
# as published by the Free Software Foundation; either version 2 of 
# the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

import sys, os, zlib, glob, shutil, re, time

programName = "Python CRC-32 Hasher"
version = "1.0"
author = "dreamer2908"

addcrc = False
force = False
recursive = False
createsfv = False
sfvPath = "checksums.sfv"
sfvContent = "; Generated by %s v%s" % (programName, version)

st_total = 0
st_ok = 0
st_notok = 0
st_notfound = 0
st_size = 0

# Open the file in binary mode (important) for reading
# Get a unit of data, call zlib.crc32 to get its hash. 
# Then get another unit, and call crc32 again; this time, 
# also give it the hash just got from previous data
# It will continue to calculate the hash. Repeat this until EOF.
# The hash got from calculating unit by unit is the same as 
# the one got from processing everything in one blast.
# Memory consuming is lower this way.
def crc32(fileName):
	fd = open(fileName,"rb")
	prev = None
	for eachLine in fd:
		if not prev:
			prev = zlib.crc32(eachLine)
		else:
			prev = zlib.crc32(eachLine, prev)
	fd.close()
	return prev

# From version 2.6, the return value is in the range [-2**31, 2**31-1], 
# and from ver 3.0, the return value is unsigned and in the range [0, 2**32-1]
# This works on both versions, confirmed by checking over 33 different files
def crc32_s(fileName):
	iHash = crc32(fileName)
	if sys.version_info[0] < 3 and iHash < 0: 
		iHash += 2 ** 32
	sHash = '%08X' % iHash
	return sHash

# In-used CRC-32 pattern: 8 characters of hexadecimal, 
# separated from the rest by some certain "special" characters.
# It's usually at the end of file name, so just take the last one; 
# there shouldn't more than one anyway.
def detectCRC(fileName):
	crc = ""
	found = False
	reCRC = re.compile(r'[A-Fa-f0-9]{8}')
	separator1 = "([_. "
	separator2 = ")]_. "
	for match in reCRC.finditer(fileName):
		start = match.start()
		end = match.end()
		if ((start == 0 or fileName[start - 1] in separator1) 
			and (end == len(fileName) or fileName[end + 1] in separator2)):
			crc = fileName[start:end]
			found = True
	return found, crc

# Err... Process one file here
def processFile(fileName):
	sHash = crc32_s(fileName)
	newName = fileName

	global st_total, st_ok, st_notok, st_notfound, st_size
	st_size += os.path.getsize(fileName)
	st_total += 1

	found, crc = detectCRC(fileName)

	if sHash in fileName.upper():
		result = "File OK!"
		st_ok += 1
	elif found:
		result = "File not OK! %s found in filename." % crc
		st_notok += 1
	else:
		if addcrc:
			namae, ext = os.path.splitext(fileName)
			newName = namae + "[%s]" % sHash + ext
			try:
				shutil.move(fileName, newName)
				result = "CRC added!"
			except:
				result = "Renaming failed!"
				newName = fileName
		else:
			result = "CRC not found!"
		st_notfound += 1

	print("%s" % fileName)
	print("CRC: %s. Result: %s" % (sHash, result))

	# Append this to sfv's content. Yes, use newName as it's up-to-date
	# Use "global" to access external variable (important)
	path, name = os.path.split(newName)
	global sfvContent
	sfvContent += "\n%s %s" % (name, sHash)

# Get all files matching mask in folder, and call processFile to process each one
def processFolder(folder, mask):
	files = glob.glob(os.path.join(folder, mask))
	for fileName in files:
		if os.path.isfile(fileName):
			processFile(fileName)

# This is for something like "/var/www/upload/*OP*", or "~/Downloads/*.mkv"
# Just split folder and mask from path, and feed them to processFile
# Additionally do some verification to protect ourselves from user's trolling
def processFolderWithMask(path):
	folder, mask = os.path.split(path)
	passed = True
	if passed:
		processFolder(folder, mask)

# Parse paramenters
pathList = []
i = 1
while i < len(sys.argv):
	arg = sys.argv[i]
	if arg == "-addcrc":
		addcrc = True
	elif arg == "-createsfv" and i < len(sys.argv) - 1:
		createsfv = True
		sfvPath = sys.argv[i+1]
		i += 1
	elif arg == "-f":
		force == True
	elif arg == "-r":
		recursive = True
	else:
		pathList.append(arg)
	i += 1

# Print user manual
if len(pathList) < 1:
	print("%s v%s by %s\n" % (programName, version, author))
	print("Syntax: python crc32.py [options] inputs\n")
	print("Input can be individual files, and/or folders.")
	print("  Use Unix shell-style wildcard for the file name pattern.\n")
	print("Options:")
	print("  -addcrc                        Add CRC to filenames")
	print("  -createsfv out.sfv             Create a SFV file")
	print("  -r                             Also include sub-folder\n")
	print("Examples:")
	print('  python crc32.py \"/home/yumi/Desktop/[FFF] Unbreakable Machine-Doll - 11 [A3A1001B].mkv\"')
	print('  python crc32.py ~/Downloads')
	print('  python crc32.py ~/Downloads/*.mkv')
	print('  python crc32.py -createsfv checksums.sfv ~/Downloads /var/www/upload/*OP*',
		' \"[FFF] Unbreakable Machine-Doll - 11 [A3A1001B].mkv\"')
	sys.exit()

# Process files and folders
start = time.clock()
for path in pathList:
	if os.path.isdir(path):
		processFolder(path, "*")
	elif os.path.isfile(path):
		processFile(path)
	elif "*" in path:
		processFolderWithMask(path)

# Print stats
elapsed = (time.clock() - start)
print("\nTotal: %d. OK: %d. Not OK: %d. CRC not found: %d." % (st_total, st_ok, st_notok, st_notok))
speed = st_size * 1.0 / elapsed
if speed >= 1000 * 1024 * 1024:
	print("Speed: %0.3f GiB read in %d sec => %0.3f GiB/s." % (st_size / (1024 * 1024 * 1024), elapsed, speed / (1024 * 1024 * 1024)))
elif speed >= 1000 * 1024:	
	print("Speed: %0.3f MiB read in %d sec => %0.3f MiB/s." % (st_size / (1024 * 1024), elapsed, speed / (1024 * 1024)))
elif speed >= 1000:	
	print("Speed: %0.3f KiB read in %d sec => %0.3f KiB/s." % (st_size / (1024), elapsed, speed / (1024)))
else:
	print("Speed: %0.3f B read in %d sec =>  %0.0f B/s." % (st_size, elapsed, speed))

# Write output SFV file
if createsfv:
	try:
		f = open(sfvPath, "w")
		f.write(sfvContent)
		f.close()
		print('\"%s\" created!' % sfvPath)
	except:
		print("Couldn't created \"%s\"!" % sfvPath)